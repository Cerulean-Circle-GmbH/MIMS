#!/usr/bin/env nu

use std assert

# global script vars
$env.SCENARIO_SRC_COMPONENT = ""
$env.SCENARIO_NAME = ""
$env.SILENTLY = false
$env.VERBOSITY = false

# don't declare type for 'msg' because it can be anything
def print_unsilent [msg] {
  if not $env.SILENTLY {
    print $msg
  }
}

# don't declare type for 'msg' because it can be anything
def print_verbose [msg] {
  if $env.VERBOSITY {
    print $msg
  }
}

def banner [msg: string] {
  print_verbose $""
  print_verbose $"####################################################################################################"
  print_verbose $"## ($msg)"
  print_verbose $"####################################################################################################"
  print_verbose $""
}

def ask_with_default [question: string, answer: string] {
  # user input as text with default value
  let user_input = (input $"($question) [($answer)] ")

  if ($user_input | is-empty) {
    $"($answer)"
  } else {
    $"($user_input)"
  }
}

def get_components [] {
  # get all available components without base path
  let base = $env.FILE_PWD | path expand
  let components = glob ./Components/**/defaults.scenario.yaml | sort # glob .. --exclude [**/localhost/*]
  $components | each { |it| str replace $"($base)/Components/" "" | str replace $"/defaults.scenario.yaml" "" }
}

def get_scenarios [] {
  # get all available scenarios without base path
  let base = $env.FILE_PWD | path expand
  let scenarios = glob ./Scenarios/**/*.{scenario,env} | sort # glob .. --exclude [**/localhost/*]
  $scenarios | each { |it| str replace $"($base)/Scenarios/" "" }
}

# run with --env to keep the env variables defined inside the script scope
def --env config [] {
  # Configure scenario
  banner $"Configure scenario"

  if ($env.SCENARIO_SRC_COMPONENT | is-empty) {
    # user input as select list
    $env.SCENARIO_SRC_COMPONENT = (get_components | input list "Choose available component dir")
  }

  if ($env.SCENARIO_NAME | is-empty) {
    # user input as select list
    $env.SCENARIO_NAME = (get_scenarios | input list "Choose available scenario")
  }

  # Convert defaults.scenario.yaml > _defaults.scenario.sh
  # TODO: This is next to implement!
}

# main command
def main [] {
  print_unsilent $"Manage once scenarios on local or remote servers.

(ansi green)Usage:(ansi reset) scenario list
       scenario deploy
  "
}

# main subcommand "list"
def "main list" [] {
  print_unsilent $"Available scenarios:"
  print_unsilent (get_scenarios)
}

# main subcommand "deploy"
def "main deploy" [
  action: string  # Actions [init,up,start,stop,down,deinit,test,updateconfig]
  scenario: string = "", # Set scenario name under which component will be deployed, e.g localhost/dev
  --verbose (-v) # Set verbosity for command
  --silent (-s) # Set silent mode for command
] {
    if $verbose {
      # set print level to debug
      $env.VERBOSITY = true
      $env.SILENTLY = false
    }

    if $silent {
      # set print level to silent
      $env.VERBOSITY = false
      $env.SILENTLY = true
    }

    $env.SCENARIO_NAME = $scenario
    config

    for $_action in ($action | split words) {
      match $_action {
      "init" => (print_verbose $"Call ($_action) ($env.SCENARIO_NAME)"),
      "up" => (print_verbose $"Call ($_action) ($env.SCENARIO_NAME)"),
      "start" => (print_verbose $"Call ($_action) ($env.SCENARIO_NAME)"),
      "stop" => (print_verbose $"Call ($_action) ($env.SCENARIO_NAME)"),
      "down" => (print_verbose $"Call ($_action) ($env.SCENARIO_NAME)"),
      "deinit" => (print_verbose $"Call ($_action) ($env.SCENARIO_NAME)"),
      "test" => (print_verbose $"Call ($_action) ($env.SCENARIO_NAME)"),
      "updateconfig" => (print_verbose $"Call ($_action) ($env.SCENARIO_NAME)"),
      _ => (print_verbose $"Unknown action ($_action)")
    }
    }
}
